#!/usr/bin/env python3

import argparse
import math
import os
import signal
from pygit2 import discover_repository, Oid, Repository, GIT_OBJ_TREE, GIT_OBJ_BLOB, GIT_OID_HEX_ZERO
from gi.repository import Gtk, GLib

parser = argparse.ArgumentParser(description='GIT blame interface')
parser.add_argument('filename', type=str, nargs='?', help='filename to analisys')
args = parser.parse_args()

cwd = os.getcwd()
repo_path = discover_repository(cwd)
repo = Repository(repo_path)

path = os.path.relpath(args.filename, repo.workdir)

class Revision:
	ZERO = Oid(hex=GIT_OID_HEX_ZERO)

	def __init__(self, commit):
		self.commit = commit
		self.id = commit.id
		self.file_id = self.ZERO
		self.parent_ids = commit.parent_ids	# Порядок важен!
		self.child_ids = set()
		self.deep = None
		self.branch = None

	def getBlobByTree(self, tree, item, tail):
		entry = next((e for e in tree if e.name == item), None)
		if not entry:
			return self.ZERO
		obj = repo[entry.id]
		if obj.type == GIT_OBJ_TREE:
			return self.getBlobByTree(obj, tail[0], tail[1:])
		assert obj.type == GIT_OBJ_BLOB
		return obj.id

	def loadObject(self, path):
		parts = path.split(os.sep)
		self.file_id = self.getBlobByTree(self.commit.tree, parts[0], parts[1:])

	def getObject(self, path):
		if self.file_id == self.ZERO:
			self.loadObject(path)
		if self.file_id == self.ZERO:
			return b''
		return repo[self.file_id].data

	def addChild(self, id):
		self.child_ids.add(id)

	def label(self):
		return '%s:%s' % (str(self.id)[:7], str(self.file_id)[:7])


commits = dict()

#def dropIdenticalChains():
#	to_drop = set()
#	for c in commits.values():
#		if not c.parent_ids or not c.child_ids:
#			continue
#		parents = [commits[pp] for pp in c.parent_ids]
#		if any((pp.file_id != c.file_id for pp in parents)):
#			continue
#		childs = [commits[cc] for cc in c.child_ids]
#		if any((cc.file_id != c.file_id for cc in childs)):
#			continue
#		# unlink current and link childs and parent
#		for cc in childs:
#			cc.parent_ids.remove(c.id)
#			cc.parent_ids.update(c.parent_ids)
#		for pp in parents:
#			pp.child_ids.remove(c.id)
#			pp.child_ids.update(c.child_ids)
#		# Cleanup current
#		c.parent_ids.clear()
#		c.child_ids.clear()
#		to_drop.add(c.id)
#	for cid in to_drop:
#		del commits[cid]
#	return bool(to_drop)


#while dropIdenticalChains():
#	pass


#def cutNonPresent():
#	root = next((c for c in commits.values() if not c.parent_ids), None)
#	if root is None or root.file_id != Oid(hex=GIT_OID_HEX_ZERO):
#		return False
#	if not root.child_ids:	# HEAD revision
#		return False
#	for p in root.child_ids:
#		parent = commits[p]
#		parent.parent_ids.remove(root.id)
#	del commits[root.id]
#	return True


#while cutNonPresent():
#	pass


#print('digraph {')

#for c in commits.values():
#	print('\t"%s" [label="%s"];' % (str(c.id)[:7], c.label()))
#	for p in c.parent_ids:
#		print('\t"%s" -> "%s";' % (str(p)[:7], str(c.id)[:7]))
	#print(str(c.id)[:7], [str(i)[:7] for i in c.parent_ids], str(c.file_id)[:7])

#print('}')

def getRevisionGrapth(progress, darea):
	todo = {repo.head.peel()}

	progress.set_text('Loading revisions...')
	while todo:
		commit = todo.pop()
		if commit.id in commits:
			continue
		revision = Revision(commit)
		#if revision.file_id == Oid(hex=GIT_OID_HEX_ZERO):
		#	revision.parent_ids.clear()
		#else:
		todo.update(commit.parents)
		commits[commit.id] = revision
		progress.set_fraction(len(commits) / float(len(commits) + len(todo)))
		yield True

	progress.set_text('Load objects...')
	progress.set_fraction(0)
	ac_step = 1.0 / len(commits)
	ac_value = 0
	for c in commits.values():
		c.loadObject(path)
		ac_value += ac_step
		progress.set_fraction(ac_value)
		yield True

	progress.set_text('Accumulate childs...')
	progress.set_fraction(0)
	ac_value = 0
	for c in commits.values():
		for p in c.parent_ids:
			commits[p].addChild(c.id)
		ac_value += ac_step
		progress.set_fraction(ac_value)
		yield True

	progress.set_text('Determine deep of tree...')
	deeped = set()
	ready = {repo.head.target}
	for d in range(0, 1000000):
		actual = {r for r in ready if commits[r].child_ids.issubset(deeped)}
		if not actual:
			break
		deeped.update(actual)
		ready.difference_update(actual)
		for a in actual:
			commits[a].deep = d
			ready.update(commits[a].parent_ids)
		progress.set_fraction(len(deeped) / len(commits))
		yield True

	tree_depth = max((c.deep for c in commits.values()))
	print("Three deep is:", tree_depth)

	progress.set_text('Determine branch width of tree...')
	ready = []
	def branch(rev, n):
		commit = commits[rev]
		while commit.branch is None:
			commit.branch = n
			if commit.parent_ids:
				commit = commits[commit.parent_ids[0]]
			else:
				return commit.deep + 1
		return commit.deep
	for n in range(0, 1000):
		unbranch = [b for b in commits.values() if b.branch is None]
		potential = [b for b in unbranch if all((commits[c].branch is not None for c in b.child_ids))]
		progress.set_fraction(1 - len(unbranch) / len(commits))
		from_d = 0
		for commit in sorted(potential, key=lambda c: c.deep):
			if commit.branch is not None or commit.deep < from_d:
				continue
			from_d = branch(commit.id, n)
			yield True
		if not any((b.branch is None for b in commits.values())):
			break

	print("Three width is:", max((c.branch for c in commits.values())))

	progress.hide()
	darea.queue_draw()


class MainWindow(Gtk.Window):
	def __init__(self):
		super().__init__(title=path + ' - Gibli')
		self.maximize()

		self.vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
		self.add(self.vbox)

		self.textview = Get.TextView()
		self.vbox.pack_start(self.textview, True, True, 0)

class Panel:
	def __init__(self, builder, textId, revId, authorId, messageId):
		self.textWidget = builder.get_object(textId)
		self.revWidget = builder.get_object(revId)
		self.authorWidget = builder.get_object(authorId)
		self.messageWidget = builder.get_object(messageId)

	def show(self, commit, path):
		blob_text = Revision(commit).getObject(path)
		self.textWidget.get_buffer().set_text(blob_text.decode('utf8'))
		self.revWidget.get_buffer().set_text(str(commit.id))
		self.authorWidget.get_buffer().set_text('%s <%s>' % (commit.author.name, commit.author.email))
		self.messageWidget.get_buffer().set_text(commit.message.splitlines()[0])


def draw_cb(widget, context):
	try:
		deep = max((c.deep for c in commits.values()))
		branch = max((c.branch for c in commits.values()))
	except:
		# Не определили еще наполнение
		return False

	width = 63 + deep * 86 + 23
	height = 23 + branch * 30 + 23
	widget.set_size_request(width, height)

	for c in commits.values():
		x = width - 23 - c.deep * 86
		y = 23 + c.branch * 30

		context.move_to(x, y - 8)
		context.set_source_rgb(0, 0, 0)
		context.arc(x, y, 8, math.pi * 1.5, math.pi * .5)
		context.line_to(x - 40, y + 8)
		context.arc(x - 40, y, 8, math.pi * .5, math.pi * 1.5)
		context.close_path()
		context.stroke_preserve()

		if c.file_id == c.ZERO:
			context.set_source_rgb(0.7, 0.7, 0.7)	# Gray
		else:
			# TODO: match with original
			context.set_source_rgb(0.4, 1, 0.4)
		context.fill()

		context.move_to(x - 40, y + 4)
		context.set_source_rgb(0, 0, 0)
		context.show_text(str(c.id)[:7])

		for pid in c.parent_ids:
			p = commits[pid]
			px = width - 23 - p.deep * 86
			py = 23 + p.branch * 30

			context.move_to(px + 8, py)
			context.set_source_rgb(0, 0, 0)
			context.curve_to(px + 23, py, px + 23, y, px + 38, y)
			context.line_to(x - 48, y)
			context.stroke()

	return False

class Application:
	def __init__(self):
		self.builder = Gtk.Builder()
		self.builder.add_from_file(os.path.dirname(__file__) + '/gibli.glade')

	def get_object(self, id):
		return self.builder.get_object(id)


if __name__ == '__main__':
	signal.signal(signal.SIGINT, signal.SIG_DFL)

	app = Application()

	main_window = app.get_object('mainwindow')
	main_window.connect('delete-event', Gtk.main_quit)
	main_window.show_all()

	main_window.maximize()

	# Paned separator setup
	paned = app.get_object('paned1')
	height = paned.get_allocated_height()
	paned.set_position(height * 0.7)

	leftPanel = Panel(app, 'leftText', 'leftRevisionText', 'leftAuthorText', 'leftCommitText')
	rightPanel = Panel(app, 'rightText', 'rightRevisionText', 'rightAuthorText', 'rightCommitText')

	head = repo.head.peel()
	rightPanel.show(head, path)

	progress = app.get_object('statusBar')
	darea = app.get_object('revisionGraph')
	loading = getRevisionGrapth(progress, darea)
	GLib.idle_add(lambda: next(loading, False), priority=GLib.PRIORITY_LOW)

	previous = head.parents[0]
	leftPanel.show(previous, path)

	darea.connect('draw', draw_cb)

	Gtk.main()
