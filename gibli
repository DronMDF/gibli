#!/usr/bin/env python3

import argparse
import math
import os
import pygit2
import signal
from gi.repository import Gtk, GLib

class Revision:
	ZERO = pygit2.Oid(hex=pygit2.GIT_OID_HEX_ZERO)

	def __init__(self, commit, repo):
		self.commit = commit
		self.repo = repo
		self.id = commit.id
		self.file_id = self.ZERO
		self.parent_ids = commit.parent_ids	# Порядок важен!
		self.child_ids = set()
		self.deep = None
		self.branch = None

	def getBlobByTree(self, tree, item, tail):
		entry = next((e for e in tree if e.name == item), None)
		if not entry:
			return self.ZERO
		obj = self.repo.get_commit(entry.id)
		if obj.type == pygit2.GIT_OBJ_TREE:
			return self.getBlobByTree(obj, tail[0], tail[1:])
		assert obj.type == pygit2.GIT_OBJ_BLOB
		return obj.id

	def loadObject(self, path):
		parts = path.split(os.sep)
		self.file_id = self.getBlobByTree(self.commit.tree, parts[0], parts[1:])

	def getObject(self, path):
		if self.file_id == self.ZERO:
			self.loadObject(path)
		if self.file_id == self.ZERO:
			return b''
		return self.repo.get_commit(self.file_id).data

	def addChild(self, id):
		self.child_ids.add(id)

	def label(self):
		return '%s:%s' % (str(self.id)[:7], str(self.file_id)[:7])


class Repository:
	MAX_BRANCHES = 500
	MAX_DEEP = 1000

	def __init__(self):
		cwd = os.getcwd()
		repo_path = pygit2.discover_repository(cwd)
		self.repo = pygit2.Repository(repo_path)

		self.commits = dict()

	def get_workdir(self):
		return self.repo.workdir

	def head(self):
		return self.repo.head.peel()

	def get_commit(self, id):
		return self.repo[id]

	def load(self, app, path):
		new_commits = dict()

		app.set_status_text('Loading revisions...')
		deep_changer = set()
		potential = [self.repo.head.target] + [None] * (self.MAX_BRANCHES - 1)
		deep = [0] * self.MAX_BRANCHES
		for c in self.repo.walk(self.repo.head.target, pygit2.GIT_SORT_TOPOLOGICAL):
			if c.id not in potential:
				continue
			revision = Revision(c, self)
			revision.branch = potential.index(revision.id)
			revision.deep = max((deep[b] for b in range(self.MAX_BRANCHES) if potential[b] == revision.id))

			for i, c in enumerate(potential):
				if c == revision.id:
					potential[i] = None
			if min((deep[b] for b in range(self.MAX_BRANCHES) if potential[b] is not None), default=0) >= self.MAX_DEEP:
				break
			if revision.deep > self.MAX_DEEP:
				continue

			new_commits[revision.id] = revision
			if revision.parent_ids:
				potential[revision.branch] = revision.parent_ids[0]
				deep[revision.branch] = revision.deep + 1
				for p in revision.parent_ids[1:]:
					branch = next((b for b in range(self.MAX_BRANCHES) if potential[b] is None and deep[b] < revision.deep + 1))
					potential[branch] = p
					deep[branch] = revision.deep + 1
			app.set_status_progress(revision.deep / self.MAX_DEEP)
			yield True

		print("Three deep is:", max(deep) - 1)
		print("Three width is:", max((c.branch for c in new_commits.values())))

		app.set_status_text('Load objects...')
		app.set_status_progress(0)
		ac_step = 1.0 / len(new_commits)
		ac_value = 0
		for c in new_commits.values():
			c.loadObject(path)
			ac_value += ac_step
			app.set_status_progress(ac_value)
			yield True

		self.commits = new_commits

		app.hide_status()
		app.redraw_revision_graph()


class Panel:
	def __init__(self, builder, textId, revId, authorId, messageId):
		self.textWidget = builder.get_object(textId)
		self.revWidget = builder.get_object(revId)
		self.authorWidget = builder.get_object(authorId)
		self.messageWidget = builder.get_object(messageId)

	def show(self, commit, repo, path):
		blob_text = Revision(commit, repo).getObject(path)
		self.textWidget.get_buffer().set_text(blob_text.decode('utf8'))
		self.revWidget.get_buffer().set_text(str(commit.id))
		self.authorWidget.get_buffer().set_text('%s <%s>' % (commit.author.name, commit.author.email))
		self.messageWidget.get_buffer().set_text(commit.message.splitlines()[0])


class Application:
	def __init__(self, repo, path):
		self.repo = repo

		self.builder = Gtk.Builder()
		self.builder.add_from_file(os.path.dirname(__file__) + '/gibli.glade')

		# Main window setup
		window = self.get_object('mainwindow')
		window.connect('delete-event', Gtk.main_quit)
		window.show_all()
		window.maximize()

		# Paned separator setup
		paned = self.get_object('paned1')
		height = paned.get_allocated_height()
		paned.set_position(height * 0.7)

		self.left_panel = Panel(self, 'leftText', 'leftRevisionText', 'leftAuthorText', 'leftCommitText')
		self.right_panel = Panel(self, 'rightText', 'rightRevisionText', 'rightAuthorText', 'rightCommitText')

		head = repo.head()
		self.right_panel.show(head, repo, path)

		self.darea = self.get_object('revisionGraph')
		self.darea.connect('draw', self.draw_cb)

		self.viewport = self.get_object('viewport1')

		self.progress = self.get_object('statusBar')

	def get_object(self, id):
		return self.builder.get_object(id)

	def set_status_text(self, text):
		self.progress.set_text(text)

	def set_status_progress(self, progress):
		self.progress.set_fraction(progress)

	def hide_status(self):
		self.progress.hide()

	def show_status(self):
		self.progress.show()

	def redraw_revision_graph(self):
		self.darea.queue_draw()

	def draw_cb(self, widget, context):
		try:
			deep = max((c.deep for c in self.repo.commits.values()))
			branch = max((c.branch for c in self.repo.commits.values()))
		except:
			# Не определили еще наполнение
			return False

		width = 63 + deep * 86 + 23
		height = 23 + branch * 30 + 23
		widget.set_size_request(width, height)

		for c in self.repo.commits.values():
			x = width - 23 - c.deep * 86
			y = 23 + c.branch * 30

			context.move_to(x, y - 8)
			context.set_source_rgb(0, 0, 0)
			context.arc(x, y, 8, math.pi * 1.5, math.pi * .5)
			context.line_to(x - 40, y + 8)
			context.arc(x - 40, y, 8, math.pi * .5, math.pi * 1.5)
			context.close_path()
			context.stroke_preserve()

			if c.file_id == c.ZERO:
				context.set_source_rgb(0.7, 0.7, 0.7)	# Gray
			else:
				# TODO: match with original
				context.set_source_rgb(0.4, 1, 0.4)
			context.fill()

			context.move_to(x - 40, y + 4)
			context.set_source_rgb(0, 0, 0)
			context.show_text(str(c.id)[:7])

			for pid in c.parent_ids:
				if pid not in self.repo.commits:
					# History may be not complete
					context.move_to(x - 48, y)
					context.set_source_rgb(0, 0, 0)
					context.line_to(0, y)
					context.stroke()
					continue
				p = self.repo.commits[pid]
				px = width - 23 - p.deep * 86
				py = 23 + p.branch * 30

				context.move_to(px + 8, py)
				context.set_source_rgb(0, 0, 0)
				context.curve_to(px + 23, py, px + 23, y, px + 38, y)
				context.line_to(x - 48, y)
				context.stroke()

		hadj = self.viewport.get_hadjustment()
		hadj.set_value(hadj.get_upper() - hadj.get_page_size())
		return False


if __name__ == '__main__':
	signal.signal(signal.SIGINT, signal.SIG_DFL)

	parser = argparse.ArgumentParser(description='GIT blame interface')
	parser.add_argument('filename', type=str, nargs='?', help='filename to analisys')
	args = parser.parse_args()

	repo = Repository()
	path = os.path.relpath(args.filename, repo.get_workdir())

	app = Application(repo, path)

	loading = repo.load(app, path)
	GLib.idle_add(lambda: next(loading, False), priority=GLib.PRIORITY_LOW)

	Gtk.main()
