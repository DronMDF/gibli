#!/usr/bin/env python3

import argparse
import itertools
import math
import os
import pygit2
import signal
from gi.repository import Gdk, Gtk, GLib

class Revision:
	ZERO = pygit2.Oid(hex=pygit2.GIT_OID_HEX_ZERO)
	ABSENT, DIFFER, EQUAL = 0, 1, 2

	def __init__(self, commit, repo, deep=None):
		self.commit = commit
		self.repo = repo
		self.id = commit.id
		self.file_id = self.ZERO
		self.state = self.ABSENT
		self.parent_ids = commit.parent_ids	# Порядок важен!
		self.deep = deep
		self.branch = None

	def getBlobByTree(self, tree, item, tail):
		entry = next((e for e in tree if e.name == item), None)
		if not entry:
			return self.ZERO
		obj = self.repo.get_commit(entry.id)
		if obj.type == pygit2.GIT_OBJ_TREE:
			return self.getBlobByTree(obj, tail[0], tail[1:])
		assert obj.type == pygit2.GIT_OBJ_BLOB
		return obj.id

	def loadObject(self, path):
		parts = path.split(os.sep)
		self.file_id = self.getBlobByTree(self.commit.tree, parts[0], parts[1:])

	def getObject(self, path):
		# Todo: is not optimal. Potential multiple object search
		if self.file_id == self.ZERO:
			self.loadObject(path)
		if self.file_id == self.ZERO:
			return b''
		return self.repo.get_commit(self.file_id).data

	def addChild(self, id):
		self.child_ids.add(id)

	def label(self):
		return '%s:%s' % (str(self.id)[:7], str(self.file_id)[:7])


class Repository:
	MAX_BRANCHES = 500
	MAX_DEEP = 1000

	def __init__(self):
		cwd = os.getcwd()
		repo_path = pygit2.discover_repository(cwd)
		self.repo = pygit2.Repository(repo_path)

		self.commits = dict()

	def get_workdir(self):
		return self.repo.workdir

	def head(self):
		return self.repo.head.peel()

	def get_commit(self, id):
		return self.repo[id]

	def load(self, app, path):
		app.set_status_text('Loading revisions...')
		app.set_status_progress(0)

		new_commits = dict()

		# Collect tree
		parents = set([self.repo.head.target])
		for deep in range(self.MAX_DEEP):
			if not parents:
				break
			next_parents = set()
			for c in parents:
				if c not in new_commits:
					new_commits[c] = Revision(self.repo[c], self, deep)
				new_commits[c].deep = deep
				next_parents.update(new_commits[c].parent_ids)
			parents = next_parents
			app.set_status_progress(deep / self.MAX_DEEP * 0.4)
			yield True
		app.set_status_progress(0.4)

		# Cleanup outofrange parents
		while parents:
			next_parents = set()
			for c in parents:
				if c in new_commits:
					next_parents.update(new_commits[c].parent_ids)
					del new_commits[c]
			parents = next_parents
			yield True
		app.set_status_progress(0.5)

		# mainline
		cr = self.repo.head.target
		while cr in new_commits:
			new_commits[cr].branch = 0
			cr = new_commits[cr].parent_ids[0] if new_commits[cr].parent_ids else None
		yield True
		app.set_status_progress(0.75)

		def branch_starter(deep, forsit):
			for rr in (r for r in new_commits.values() if r.deep == deep and r.branch is not None):
				if not forsit.isdisjoint(rr.parent_ids):
					return rr

		for branch in range(1, self.MAX_BRANCHES):
			forsit = {v.id for v in new_commits.values() if v.branch is None}
			app.set_status_progress(1 - len(forsit) / len(new_commits) * 0.25)
			if not forsit:
				break
			deep = 0
			while deep < self.MAX_DEEP:
				br = branch_starter(deep, forsit)
				while br is not None:
					br = next((new_commits[p] for p in forsit & set(br.parent_ids)
						if new_commits[p].deep >= deep), None)
					if br is not None:
						br.branch = branch
						if any((p not in new_commits for p in br.parent_ids)):
							deep = self.MAX_DEEP
							break
						if any((new_commits[p].branch is not None for p in br.parent_ids if p in new_commits)):
							deep = max((new_commits[p].deep - 1 for p in br.parent_ids
								if p in new_commits and new_commits[p].branch is not None))
						deep += 1
				deep += 1
			yield True

		print("Three deep is:", max((c.deep for c in new_commits.values())))
		print("Three width is:", max((c.branch for c in new_commits.values())))

		app.set_status_text('Load objects...')
		app.set_status_progress(0)
		ac_step = 1.0 / len(new_commits)
		ac_value = 0
		for c in new_commits.values():
			c.loadObject(path)
			ac_value += ac_step
			app.set_status_progress(ac_value)
			yield True

		self.commits = new_commits
		self.search_difference()

		app.hide_status()
		app.redraw_revision_graph()

	def search_difference(self):
		right_file_id = self.commits[self.repo.head.target].file_id
		for c in self.commits.values():
			if c.file_id == right_file_id:
				c.state = c.EQUAL
			elif c.file_id == c.ZERO:
				c.state = c.ABSENT
			else:
				c.state = c.DIFFER


class Panel:
	def __init__(self, builder, textId, revId, authorId, messageId):
		self.textWidget = builder.get_object(textId)
		self.revWidget = builder.get_object(revId)
		self.authorWidget = builder.get_object(authorId)
		self.messageWidget = builder.get_object(messageId)

	def show(self, commit, repo, path):
		blob_text = Revision(commit, repo).getObject(path)
		self.textWidget.get_buffer().set_text(blob_text.decode('utf8'))
		self.revWidget.get_buffer().set_text(str(commit.id))
		self.authorWidget.get_buffer().set_text('%s <%s>' % (commit.author.name, commit.author.email))
		self.messageWidget.get_buffer().set_text(commit.message.splitlines()[0])


class Application:
	def __init__(self, repo, path):
		self.repo = repo

		self.builder = Gtk.Builder()
		self.builder.add_from_file(os.path.dirname(__file__) + '/gibli.glade')

		# Main window setup
		window = self.get_object('mainwindow')
		window.connect('delete-event', Gtk.main_quit)
		window.show_all()
		window.maximize()

		# Paned separator setup
		paned = self.get_object('paned1')
		height = paned.get_allocated_height()
		paned.set_position(height * 0.7)

		self.left_panel = Panel(self, 'leftText', 'leftRevisionText', 'leftAuthorText', 'leftCommitText')
		self.right_panel = Panel(self, 'rightText', 'rightRevisionText', 'rightAuthorText', 'rightCommitText')

		head = repo.head()
		self.right_panel.show(head, repo, path)

		self.darea = self.get_object('revisionGraph')
		self.darea.connect('draw', self.draw_cb)
		self.darea.connect('button-press-event', self.on_graph_click)

		self.viewport = self.get_object('viewport1')
		hadj = self.viewport.get_hadjustment()
		vadj = self.viewport.get_vadjustment()
		self.hposition = hadj.get_page_size()
		self.vposition = 0
		hadj.connect('value_changed', self.on_hscroll)
		vadj.connect('value_changed', self.on_vscroll)

		self.progress = self.get_object('statusBar')

	def get_object(self, id):
		return self.builder.get_object(id)

	def set_status_text(self, text):
		self.progress.set_text(text)

	def set_status_progress(self, progress):
		self.progress.set_fraction(progress)

	def hide_status(self):
		self.progress.hide()

	def show_status(self):
		self.progress.show()

	def redraw_revision_graph(self):
		self.darea.queue_draw()

	def on_hscroll(self, adj):
		self.hposition = adj.get_upper() - adj.get_value()

	def on_vscroll(self, adj):
		self.vposition = adj.get_value()

	def draw_cb(self, widget, context):
		try:
			deep = max((c.deep for c in self.repo.commits.values()))
			branch = max((c.branch for c in self.repo.commits.values()))
		except:
			# Не определили еще наполнение
			return False

		width = 63 + deep * 86 + 23
		height = 23 + branch * 30 + 23
		widget.set_size_request(width, height)

		for c in self.repo.commits.values():
			x = width - 23 - c.deep * 86
			y = 23 + c.branch * 30

			context.move_to(x, y - 8)
			context.set_source_rgb(0, 0, 0)
			context.arc(x, y, 8, math.pi * 1.5, math.pi * .5)
			context.line_to(x - 40, y + 8)
			context.arc(x - 40, y, 8, math.pi * .5, math.pi * 1.5)
			context.close_path()
			context.stroke_preserve()

			if c.state == c.ABSENT:
				context.set_source_rgb(0.7, 0.7, 0.7)	# Gray
			elif c.state == c.DIFFER:
				context.set_source_rgb(1, 0.4, 0.4)	# Red
			else:
				context.set_source_rgb(0.4, 1, 0.4)	# Green
			context.fill()

			context.move_to(x - 40, y + 4)
			context.set_source_rgb(0, 0, 0)
			context.show_text(str(c.id)[:7])

			for pid in c.parent_ids:
				if pid not in self.repo.commits:
					# History may be not complete
					context.move_to(x - 48, y)
					context.set_source_rgb(0, 0, 0)
					context.line_to(0, y)
					context.stroke()
					continue
				p = self.repo.commits[pid]
				px = width - 23 - p.deep * 86
				py = 23 + p.branch * 30

				context.move_to(px + 8, py)
				context.set_source_rgb(0, 0, 0)
				if p.branch > c.branch:
					context.line_to(x - 78, py)
					context.curve_to(x - 63, py, x - 63, y, x - 48, y)
				else:
					context.curve_to(px + 23, py, px + 23, y, px + 38, y)
				context.line_to(x - 48, y)
				context.stroke()

		hadj = self.viewport.get_hadjustment()
		hadj.set_value(hadj.get_upper() - self.hposition)
		vadj = self.viewport.get_vadjustment()
		vadj.set_value(self.vposition)
		return False

	def on_graph_click(self, widget, event):
		# event.x and event.y keep position in darea
		width, hewight = widget.get_size_request()
		deep = int((width - event.x) / 86)
		branch = int((event.y - 8) / 30)

		commit = next((c for c in self.repo.commits.values() if c.branch == branch and c.deep == deep), None)
		if commit is not None:
			print(deep, branch, commit.id)
		return True


if __name__ == '__main__':
	signal.signal(signal.SIGINT, signal.SIG_DFL)

	parser = argparse.ArgumentParser(description='GIT blame interface')
	parser.add_argument('filename', type=str, nargs='?', help='filename to analisys')
	args = parser.parse_args()

	repo = Repository()
	path = os.path.relpath(args.filename, repo.get_workdir())

	app = Application(repo, path)

	loading = repo.load(app, path)
	GLib.idle_add(lambda: next(loading, False), priority=GLib.PRIORITY_LOW)

	Gtk.main()
