#!/usr/bin/env python3

import os
from pygit2 import discover_repository, Oid, Repository, GIT_OBJ_TREE, GIT_OBJ_BLOB, GIT_OID_HEX_ZERO

cwd = os.getcwd()
repo_path = discover_repository(cwd)
repo = Repository(repo_path)

path = 'arch/x86/Makefile'

def getBlobByTree(tree, item, tail):
	entry = next((e for e in tree if e.name == item), None)
	if not entry:
		return Oid(hex=GIT_OID_HEX_ZERO)
	obj = repo[entry.id]
	if obj.type == GIT_OBJ_TREE:
		return getBlobByTree(obj, tail[0], tail[1:])
	assert obj.type == GIT_OBJ_BLOB
	return obj.id

def getBlob(tree, path):
	parts = path.split(os.sep)
	return getBlobByTree(tree, parts[0], parts[1:])

class Revision:
	def __init__(self, commit):
		self.commit = commit
		self.id = commit.id
		self.parent_ids = set(commit.parent_ids)
		self.child_ids = set()
		self.file_id = getBlob(commit.tree, path)

	def addChild(self, id):
		self.child_ids.add(id)


commits = dict()
todo = {repo.head.peel()}

while todo:
	commit = todo.pop()
	if commit.id in commits:
		continue
	commits[commit.id] = Revision(commit)
	todo.update(commit.parents)

# Accumulate childs
for c in commits.values():
	for p in c.parent_ids:
		commits[p].addChild(c.id)

def dropIdenticalChains():
	to_drop = set()
	for c in commits.values():
		if len(c.parent_ids) != 1 or len(c.child_ids) != 1:
			continue
		parent = commits[next(iter(c.parent_ids))]
		if parent.file_id != c.file_id:
			continue
		child = commits[next(iter(c.child_ids))]
		if child.file_id != c.file_id:
			continue
		# unlink from three
		child.parent_ids.remove(c.id)
		parent.child_ids.remove(c.id)
		c.parent_ids.clear()
		c.child_ids.clear()
		to_drop.add(c.id)
		# link child and parent
		child.parent_ids.add(parent.id)
		parent.child_ids.add(child.id)
	for cid in to_drop:
		del commits[cid]
	return bool(to_drop)


while True:
	idrop = dropIdenticalChains()
	if not idrop:
		break


for c in commits.values():
	print(str(c.id)[:7], [str(i)[:7] for i in c.parent_ids], str(c.file_id)[:7])
