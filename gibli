#!/usr/bin/env python3

import argparse
import math
import os
import pygit2
import signal
from gi.repository import Gtk, GLib

class Revision:
	ZERO = pygit2.Oid(hex=pygit2.GIT_OID_HEX_ZERO)

	def __init__(self, commit, repo):
		self.commit = commit
		self.repo = repo
		self.id = commit.id
		self.file_id = self.ZERO
		self.parent_ids = commit.parent_ids	# Порядок важен!
		self.child_ids = set()
		self.deep = None
		self.branch = None

	def getBlobByTree(self, tree, item, tail):
		entry = next((e for e in tree if e.name == item), None)
		if not entry:
			return self.ZERO
		obj = self.repo.get_commit(entry.id)
		if obj.type == pygit2.GIT_OBJ_TREE:
			return self.getBlobByTree(obj, tail[0], tail[1:])
		assert obj.type == pygit2.GIT_OBJ_BLOB
		return obj.id

	def loadObject(self, path):
		parts = path.split(os.sep)
		self.file_id = self.getBlobByTree(self.commit.tree, parts[0], parts[1:])

	def getObject(self, path):
		if self.file_id == self.ZERO:
			self.loadObject(path)
		if self.file_id == self.ZERO:
			return b''
		return self.repo.get_commit(self.file_id).data

	def addChild(self, id):
		self.child_ids.add(id)

	def label(self):
		return '%s:%s' % (str(self.id)[:7], str(self.file_id)[:7])


class Repository:
	def __init__(self):
		cwd = os.getcwd()
		repo_path = pygit2.discover_repository(cwd)
		self.repo = pygit2.Repository(repo_path)

		self.commits = dict()

	def get_workdir(self):
		return self.repo.workdir

	def head(self):
		return self.repo.head.peel()

	def get_commit(self, id):
		return self.repo[id]

	def load(self, app, path):
		todo = {self.repo.head.peel()}

		app.set_status_text('Loading revisions...')
		while todo:
			commit = todo.pop()
			if commit.id in self.commits:
				continue
			revision = Revision(commit, self)
			todo.update(commit.parents)
			self.commits[commit.id] = revision
			app.set_status_progress(len(self.commits) / float(len(self.commits) + len(todo)))
			yield True

		app.set_status_text('Load objects...')
		app.set_status_progress(0)
		ac_step = 1.0 / len(self.commits)
		ac_value = 0
		for c in self.commits.values():
			c.loadObject(path)
			ac_value += ac_step
			app.set_status_progress(ac_value)
			yield True

		app.set_status_text('Accumulate childs...')
		app.set_status_progress(0)
		ac_value = 0
		for c in self.commits.values():
			for p in c.parent_ids:
				self.commits[p].addChild(c.id)
			ac_value += ac_step
			app.set_status_progress(ac_value)
			yield True

		app.set_status_text('Determine deep of tree...')
		deeped = set()
		ready = {self.repo.head.target}
		for d in range(0, 1000000):
			actual = {r for r in ready if self.commits[r].child_ids.issubset(deeped)}
			if not actual:
				break
			deeped.update(actual)
			ready.difference_update(actual)
			for a in actual:
				self.commits[a].deep = d
				ready.update(self.commits[a].parent_ids)
			app.set_status_progress(len(deeped) / len(self.commits))
			yield True

		tree_depth = max((c.deep for c in self.commits.values()))
		print("Three deep is:", tree_depth)

		app.set_status_text('Determine branch width of tree...')
		ready = []
		def branch(rev, n):
			commit = self.commits[rev]
			while commit.branch is None:
				commit.branch = n
				if commit.parent_ids:
					commit = self.commits[commit.parent_ids[0]]
				else:
					return commit.deep + 1
			return commit.deep
		for n in range(0, 1000):
			unbranch = [b for b in self.commits.values() if b.branch is None]
			potential = [b for b in unbranch if all((self.commits[c].branch is not None for c in b.child_ids))]
			app.set_status_progress(1 - len(unbranch) / len(self.commits))
			from_d = 0
			for commit in sorted(potential, key=lambda c: c.deep):
				if commit.branch is not None or commit.deep < from_d:
					continue
				from_d = branch(commit.id, n)
				yield True
			if not any((b.branch is None for b in self.commits.values())):
				break

		print("Three width is:", max((c.branch for c in self.commits.values())))

		app.hide_status()
		app.redraw_revision_graph()


class Panel:
	def __init__(self, builder, textId, revId, authorId, messageId):
		self.textWidget = builder.get_object(textId)
		self.revWidget = builder.get_object(revId)
		self.authorWidget = builder.get_object(authorId)
		self.messageWidget = builder.get_object(messageId)

	def show(self, commit, repo, path):
		blob_text = Revision(commit, repo).getObject(path)
		self.textWidget.get_buffer().set_text(blob_text.decode('utf8'))
		self.revWidget.get_buffer().set_text(str(commit.id))
		self.authorWidget.get_buffer().set_text('%s <%s>' % (commit.author.name, commit.author.email))
		self.messageWidget.get_buffer().set_text(commit.message.splitlines()[0])


class Application:
	def __init__(self, repo, path):
		self.repo = repo

		self.builder = Gtk.Builder()
		self.builder.add_from_file(os.path.dirname(__file__) + '/gibli.glade')

		# Main window setup
		window = self.get_object('mainwindow')
		window.connect('delete-event', Gtk.main_quit)
		window.show_all()
		window.maximize()

		# Paned separator setup
		paned = self.get_object('paned1')
		height = paned.get_allocated_height()
		paned.set_position(height * 0.7)

		self.left_panel = Panel(self, 'leftText', 'leftRevisionText', 'leftAuthorText', 'leftCommitText')
		self.right_panel = Panel(self, 'rightText', 'rightRevisionText', 'rightAuthorText', 'rightCommitText')

		head = repo.head()
		self.right_panel.show(head, repo, path)

		self.darea = self.get_object('revisionGraph')
		self.darea.connect('draw', self.draw_cb)

		self.progress = self.get_object('statusBar')

	def get_object(self, id):
		return self.builder.get_object(id)

	def set_status_text(self, text):
		self.progress.set_text(text)

	def set_status_progress(self, progress):
		self.progress.set_fraction(progress)

	def hide_status(self):
		self.progress.hide()

	def show_status(self):
		self.progress.show()

	def redraw_revision_graph(self):
		self.darea.queue_draw()

	def draw_cb(self, widget, context):
		try:
			deep = max((c.deep for c in self.repo.commits.values()))
			branch = max((c.branch for c in self.repo.commits.values()))
		except:
			# Не определили еще наполнение
			return False

		width = 63 + deep * 86 + 23
		height = 23 + branch * 30 + 23
		widget.set_size_request(width, height)

		for c in self.repo.commits.values():
			x = width - 23 - c.deep * 86
			y = 23 + c.branch * 30

			context.move_to(x, y - 8)
			context.set_source_rgb(0, 0, 0)
			context.arc(x, y, 8, math.pi * 1.5, math.pi * .5)
			context.line_to(x - 40, y + 8)
			context.arc(x - 40, y, 8, math.pi * .5, math.pi * 1.5)
			context.close_path()
			context.stroke_preserve()

			if c.file_id == c.ZERO:
				context.set_source_rgb(0.7, 0.7, 0.7)	# Gray
			else:
				# TODO: match with original
				context.set_source_rgb(0.4, 1, 0.4)
			context.fill()

			context.move_to(x - 40, y + 4)
			context.set_source_rgb(0, 0, 0)
			context.show_text(str(c.id)[:7])

			for pid in c.parent_ids:
				p = self.repo.commits[pid]
				px = width - 23 - p.deep * 86
				py = 23 + p.branch * 30

				context.move_to(px + 8, py)
				context.set_source_rgb(0, 0, 0)
				context.curve_to(px + 23, py, px + 23, y, px + 38, y)
				context.line_to(x - 48, y)
				context.stroke()
		return False


if __name__ == '__main__':
	signal.signal(signal.SIGINT, signal.SIG_DFL)

	parser = argparse.ArgumentParser(description='GIT blame interface')
	parser.add_argument('filename', type=str, nargs='?', help='filename to analisys')
	args = parser.parse_args()

	repo = Repository()
	path = os.path.relpath(args.filename, repo.get_workdir())

	app = Application(repo, path)

	loading = repo.load(app, path)
	GLib.idle_add(lambda: next(loading, False), priority=GLib.PRIORITY_LOW)

	Gtk.main()
